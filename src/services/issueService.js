// backend/src/services/issueService.js
const gitlab = require('./gitlabService');
const { makeFingerprint, normStr } = require('../utils/aiHelpers');
const fpStore = require('../db/fingerprintStore');

const MIN_CONF_TO_AUTOCREATE = Number(process.env.MIN_CONF_CREATE || 0.6);
const GITLAB_BASE_URL = process.env.GITLAB_BASE_URL || 'https://gitlab.com';

async function createIssueFromAnalysis(projectId, { pipelineId, job, analysis, logExcerpt = '', commitSha = '' }) {
  // Ensure fingerprint store ready
  // (Assumes init already called in app bootstrap)
  const excerptSlice = normStr(logExcerpt).slice(0, 200);
  const fingerprint = makeFingerprint({
    projectId,
    jobId: job.id,
    pipelineId,
    commitSha,
    excerpt: excerptSlice
  });

  // 1) Try DB atomic insert fallback: check if exists
  const existing = await fpStore.getByFingerprint(fingerprint).catch(() => null);
  if (existing && existing.issue_iid) {
    // Append comment instead of creating new issue
    const commentBody = buildCommentBody({ pipelineId, job, analysis, logExcerpt });
    await gitlab.createIssueComment(projectId, existing.issue_iid, commentBody).catch((err) => {
      console.error('Failed to append comment for existing fingerprint:', err.message);
    });
    // bump occurrence counter
    await fpStore.bumpOccurrence(fingerprint).catch(() => {});
    // return a lightweight object indicating existing issue
    return { existing: true, issue_iid: existing.issue_iid };
  }

  // 2) If not in DB, search GitLab open issues for fingerprint (fallback)
  let foundRemote = null;
  try {
    const matches = await gitlab.searchOpenIssues(projectId, fingerprint).catch(() => []);
    if (Array.isArray(matches) && matches.length > 0) {
      foundRemote = matches[0];
    }
  } catch (err) {
    console.warn('Issue search failed:', err.message);
  }

  if (foundRemote) {
    // store mapping in DB best-effort
    try {
      await fpStore.insertMappingAtomic({ fingerprint, projectId, issueIid: foundRemote.iid });
    } catch (e) {
      // ignore
    }
    const commentBody = buildCommentBody({ pipelineId, job, analysis, logExcerpt });
    await gitlab.createIssueComment(projectId, foundRemote.iid, commentBody).catch((err) => {
      console.error('Failed to append comment to remote found issue:', err.message);
    });
    return { existing: true, issue_iid: foundRemote.iid };
  }

  // 3) No existing issue — apply confidence gating
  const confidence = typeof analysis.confidence === 'number' ? analysis.confidence : 0;
  const labels = ['ai:analysis'];
  if (confidence < MIN_CONF_TO_AUTOCREATE) {
    labels.push('ai:triage');
  }
  // Severity label heuristic (simple)
  if ((analysis.root_cause || '').toLowerCase().includes('secret') || (analysis.root_cause || '').toLowerCase().includes('api key')) {
    labels.push('ai:security', 'severity:critical');
  }

  const title = `[AUTO] CI analysis — ${job.name} (pipeline ${pipelineId}) [fp:${fingerprint}]`;
  const jobUrl = job.web_url || `${GITLAB_BASE_URL}/${projectId}/-/jobs/${job.id}`;
  const pipelineUrl = `${GITLAB_BASE_URL}/${projectId}/-/pipelines/${pipelineId}`;

  const description = [
    '**AI Analysis**',
    `**Stage:** ${analysis.stage || job.name}`,
    `**Root cause:** ${analysis.root_cause || 'unknown'}`,
    `**Suggested fix:** ${analysis.suggested_fix || 'manual review'}`,
    `**Confidence:** ${analysis.confidence ?? 0}`,
    `**Fingerprint:** ${fingerprint}`,
    '',
    `**Pipeline:** ${pipelineUrl}`,
    `**Job:** ${jobUrl}`,
    '',
    '**Log excerpt:**',
    '```',
    logExcerpt || '(no excerpt captured)',
    '```',
    '',
    '_This issue was auto-generated by the AI DevOps Assistant. Prompt and response stored for audit._'
  ].join('\n');

  // Create issue on GitLab
  const newIssue = await gitlab.createIssue(projectId, title, description, labels).catch((err) => {
    throw new Error(`Failed to create issue: ${err.message}`);
  });

  // Atomically insert mapping into DB. If another process raced and inserted, insertMappingAtomic will return existing mapping.
  try {
    const mapping = await fpStore.insertMappingAtomic({ fingerprint, projectId, issueIid: newIssue.iid });
    // mapping returned either the new mapping or existing mapping if race occurred
    if (mapping && mapping.issue_iid && mapping.issue_iid !== newIssue.iid) {
      // race: another process created the mapping first — append a comment to the winner and optionally close duplicate (not doing deletion here)
      const winnerIid = mapping.issue_iid;
      const commentBody = `Duplicate issue created (race). Consolidating evidence into existing issue #${winnerIid}.`;
      // Append comment to newIssue to indicate consolidation
      await gitlab.createIssueComment(projectId, newIssue.iid, commentBody).catch(() => {});
      // Also append real evidence to the winning issue
      const realEvidence = buildCommentBody({ pipelineId, job, analysis, logExcerpt });
      await gitlab.createIssueComment(projectId, winnerIid, realEvidence).catch(() => {});
      // You may choose to close the duplicate newIssue programmatically if policy allows.
      return { existing: true, issue_iid: winnerIid, duplicate_created: newIssue.iid };
    }
  } catch (err) {
    // mapping insert failed unexpectedly — log but keep issue
    console.warn('Mapping insert warning:', err.message);
  }

  return newIssue;
}

function buildCommentBody({ pipelineId, job, analysis, logExcerpt }) {
  const jobUrl = job.web_url || '';
  return [
    `**New occurrence detected**`,
    `**Pipeline:** ${pipelineId}`,
    `**Job:** ${job.name} (${job.id})`,
    `**Root cause:** ${analysis.root_cause || 'unknown'}`,
    `**Confidence:** ${analysis.confidence ?? 0}`,
    '',
    '**Log excerpt:**',
    '```',
    logExcerpt || '(no excerpt captured)',
    '```',
    '',
    '_Appended automatically by AI Guardian._'
  ].join('\n');
}

module.exports = { createIssueFromAnalysis };
